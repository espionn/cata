{"version":3,"file":"sim-CWeOXBK6.chunk.js","sources":["../../../ui/core/components/suggest_gems_action.ts","../../../ui/druid/feral/inputs.ts","../../../ui/druid/feral/presets.ts","../../../ui/druid/feral/sim.ts"],"sourcesContent":["import { IndividualSimUI } from '../individual_sim_ui.js';\nimport { Player } from '../player.js';\nimport { GemColor, ItemSlot, Profession, Spec, Stat } from '../proto/common.js';\nimport { EquippedItem } from '../proto_utils/equipped_item.js';\nimport { Gear } from '../proto_utils/gear.js';\nimport { Stats } from '../proto_utils/stats.js';\nimport { Sim } from '../sim.js';\nimport { TypedEvent } from '../typed_event.js';\n\ninterface GemCapsData {\n\tgemId: number;\n\tstatCaps: Stats;\n}\n\ninterface SocketData {\n\titemSlot: ItemSlot;\n\tsocketIdx: number;\n}\n\ninterface SocketBonusData {\n\titemSlot: ItemSlot | null;\n\tsocketBonus: number;\n}\n\nabstract class GemOptimizer {\n\tprotected readonly player: Player<any>;\n\tprotected readonly sim: Sim;\n\tprotected readonly gemPriorityByColor: Record<GemColor, Array<GemCapsData>>;\n\tabstract metaGemID: number;\n\tstatic allGemColors: Array<GemColor> = [GemColor.GemColorRed, GemColor.GemColorYellow, GemColor.GemColorBlue];\n\tepWeights!: Stats;\n\tuseJcGems!: boolean;\n\tisBlacksmithing!: boolean;\n\tnumSocketedJcGems!: number;\n\tjcUpgradePriority: Array<GemCapsData>;\n\n\tstatic jcUpgradesById: Record<number, number> = {\n\t\t40118: 42154,\n\t\t40125: 42156,\n\t\t40112: 42143,\n\t\t40111: 42142,\n\t\t40119: 36767,\n\t};\n\n\tconstructor(simUI: IndividualSimUI<any>) {\n\t\tthis.player = simUI.player;\n\t\tthis.sim = simUI.sim;\n\n\t\t// Initialize empty arrays of gem priorities for each socket color\n\t\tthis.gemPriorityByColor = {} as Record<GemColor, Array<GemCapsData>>;\n\n\t\tfor (const gemColor of GemOptimizer.allGemColors) {\n\t\t\tthis.gemPriorityByColor[gemColor] = new Array<GemCapsData>();\n\t\t}\n\n\t\tthis.jcUpgradePriority = new Array<GemCapsData>();\n\n\t\tsimUI.addAction('Suggest Gems', 'suggest-gems-action', async () => {\n\t\t\tthis.optimizeGems();\n\t\t});\n\t}\n\n\tasync optimizeGems() {\n\t\t// First, clear all existing gems\n\t\tlet optimizedGear = this.player.getGear().withoutGems();\n\t\tthis.numSocketedJcGems = 0;\n\n\t\t// Store relevant player attributes for use in optimizations\n\t\tthis.epWeights = this.player.getEpWeights();\n\t\tthis.useJcGems = this.player.hasProfession(Profession.Jewelcrafting);\n\t\tthis.isBlacksmithing = this.player.isBlacksmithing();\n\n\t\t/*\n\t\t * Use subclass-specific logic to rank order gems of each color by value\n\t\t * and calculate the associated stat caps for each gem (when applicable).\n\t\t */\n\t\tconst ungemmedStats = await this.updateGear(optimizedGear);\n\t\tthis.updateGemPriority(optimizedGear, ungemmedStats);\n\n\t\t// Next, socket and activate the meta\n\t\toptimizedGear = optimizedGear.withMetaGem(this.sim.db.lookupGem(this.metaGemID));\n\t\toptimizedGear = this.activateMetaGem(optimizedGear);\n\t\tawait this.updateGear(optimizedGear);\n\n\t\t// Now loop through all gem colors where a priority list has been defined\n\t\tfor (const gemColor of GemOptimizer.allGemColors) {\n\t\t\tif (this.gemPriorityByColor[gemColor].length > 0) {\n\t\t\t\toptimizedGear = await this.fillGemsByColor(optimizedGear, gemColor);\n\n\t\t\t\t// Also substitute JC gems by priority while respecting stat caps\n\t\t\t\tif (this.useJcGems) {\n\t\t\t\t\toptimizedGear = await this.substituteJcGems(optimizedGear);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tasync updateGear(gear: Gear): Promise<Stats> {\n\t\tthis.player.setGear(TypedEvent.nextEventID(), gear);\n\t\tawait this.sim.updateCharacterStats(TypedEvent.nextEventID());\n\t\treturn Stats.fromProto(this.player.getCurrentStats().finalStats);\n\t}\n\n\t/**\n\t * Helper method for meta gem activation.\n\t *\n\t * @remarks\n\t * Based on the ansatz that most specs are forced to use a suboptimal gem color in\n\t * order to statisfy their meta requirements. As a result, it is helpful to\n\t * compute the item slot in a gear set that provides the strongest socket bonus\n\t * for that color, since this should minimize the \"cost\" of activation.\n\t *\n\t * @param gear - Ungemmed gear set\n\t * @param color - Socket color used for meta gem activation\n\t * @param singleOnly - If true, exclude items containing more than one socket of the specified color. If false, instead normalize the socket bonus by the number of such sockets.\n\t * @param blacklistedColor - If non-null, exclude items containing any sockets of this color (assumed to be different from the color used for activation).\n\t * @returns Optimal item slot for activation under the specified constraints, or null if not found.\n\t */\n\tfindStrongestSocketBonus(gear: Gear, color: GemColor, singleOnly: boolean, blacklistedColor: GemColor | null): SocketBonusData {\n\t\tlet optimalSlot: ItemSlot | null = null;\n\t\tlet maxSocketBonusEP = 1e-8;\n\n\t\tfor (const slot of gear.getItemSlots()) {\n\t\t\tconst item = gear.getEquippedItem(slot);\n\n\t\t\tif (!item) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (item.numSocketsOfColor(blacklistedColor) != 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst numSockets = item.numSocketsOfColor(color);\n\n\t\t\tif (numSockets == 0 || (singleOnly && numSockets != 1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst socketBonusEP = new Stats(item.item.socketBonus).computeEP(this.epWeights);\n\t\t\tconst normalizedEP = socketBonusEP / numSockets;\n\n\t\t\tif (normalizedEP > maxSocketBonusEP) {\n\t\t\t\toptimalSlot = slot;\n\t\t\t\tmaxSocketBonusEP = normalizedEP;\n\t\t\t}\n\t\t}\n\n\t\treturn { itemSlot: optimalSlot, socketBonus: maxSocketBonusEP };\n\t}\n\n\tsocketGemInFirstMatchingSocket(gear: Gear, itemSlot: ItemSlot | null, colorToMatch: GemColor, gemId: number): Gear {\n\t\tif (itemSlot != null) {\n\t\t\tconst item = gear.getEquippedItem(itemSlot);\n\n\t\t\tif (!item) {\n\t\t\t\treturn gear;\n\t\t\t}\n\n\t\t\tfor (const [socketIdx, socketColor] of item!.allSocketColors().entries()) {\n\t\t\t\tif (socketColor == colorToMatch) {\n\t\t\t\t\treturn gear.withEquippedItem(itemSlot, item!.withGem(this.sim.db.lookupGem(gemId), socketIdx), true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn gear;\n\t}\n\n\tasync fillGemsByColor(gear: Gear, color: GemColor): Promise<Gear> {\n\t\tconst socketList = this.findSocketsByColor(gear, color);\n\t\treturn await this.fillGemsToCaps(gear, socketList, this.gemPriorityByColor[color], 0, 0);\n\t}\n\n\t/**\n\t * Shared wrapper for compiling eligible sockets for each gem priority list.\n\t *\n\t * @remarks\n\t * Subclasses are required to implement the allowGemInSocket method, which\n\t * contains the (spec-specific) logic on when to match socket bonuses etc.\n\t *\n\t * @param gear - Partially gemmed gear set\n\t * @param color - Color associated with a single gem priority list\n\t * @returns Array of sockets that will be filled using the priority list associated with the specified color.\n\t */\n\tfindSocketsByColor(gear: Gear, color: GemColor): Array<SocketData> {\n\t\tconst socketList = new Array<SocketData>();\n\n\t\tfor (const slot of gear.getItemSlots()) {\n\t\t\tconst item = gear.getEquippedItem(slot);\n\n\t\t\tif (!item) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (const [socketIdx, socketColor] of item.curSocketColors(this.isBlacksmithing).entries()) {\n\t\t\t\tif (item!.hasSocketedGem(socketIdx)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (this.allowGemInSocket(color, socketColor, slot, item)) {\n\t\t\t\t\tsocketList.push({ itemSlot: slot, socketIdx: socketIdx });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn socketList;\n\t}\n\n\tasync substituteJcGems(gear: Gear): Promise<Gear> {\n\t\tlet updatedGear: Gear = gear;\n\t\tlet gemIdx = 0;\n\n\t\twhile (this.numSocketedJcGems < 3 && gemIdx < this.jcUpgradePriority.length) {\n\t\t\tconst gemData = this.jcUpgradePriority[gemIdx];\n\t\t\tconst baseGem = this.sim.db.lookupGem(gemData.gemId);\n\n\t\t\tif (!updatedGear.getAllGems(this.isBlacksmithing).includes(baseGem!)) {\n\t\t\t\tgemIdx += 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst upgradedGem = this.sim.db.lookupGem(GemOptimizer.jcUpgradesById[gemData.gemId]);\n\t\t\tconst testGear = updatedGear.withSingleGemSubstitution(baseGem, upgradedGem, this.isBlacksmithing);\n\t\t\tconst newStats = await this.updateGear(testGear);\n\n\t\t\tif (newStats.belowCaps(gemData.statCaps)) {\n\t\t\t\tupdatedGear = testGear;\n\t\t\t\tthis.numSocketedJcGems += 1;\n\t\t\t} else {\n\t\t\t\tawait this.updateGear(updatedGear);\n\t\t\t\tgemIdx += 1;\n\t\t\t}\n\t\t}\n\n\t\treturn updatedGear;\n\t}\n\n\tasync fillGemsToCaps(gear: Gear, socketList: Array<SocketData>, gemCaps: Array<GemCapsData>, numPasses: number, firstIdx: number): Promise<Gear> {\n\t\tlet updatedGear: Gear = gear;\n\t\tconst currentGem = this.sim.db.lookupGem(gemCaps[numPasses].gemId);\n\n\t\t// On the first pass, we simply fill all sockets with the highest priority gem\n\t\tif (numPasses == 0) {\n\t\t\tfor (const socketData of socketList.slice(firstIdx)) {\n\t\t\t\tupdatedGear = updatedGear.withGem(socketData.itemSlot, socketData.socketIdx, currentGem);\n\t\t\t}\n\t\t}\n\n\t\t// If we are below the relevant stat cap for the gem we just filled on the last pass, then we are finished.\n\t\tlet newStats = await this.updateGear(updatedGear);\n\t\tconst currentCap = gemCaps[numPasses].statCaps;\n\n\t\tif (newStats.belowCaps(currentCap) || numPasses == gemCaps.length - 1) {\n\t\t\treturn updatedGear;\n\t\t}\n\n\t\t// If we exceeded the stat cap, then work backwards through the socket list and replace each gem with the next highest priority option until we are below the cap\n\t\tconst nextGem = this.sim.db.lookupGem(gemCaps[numPasses + 1].gemId);\n\t\tconst nextCap = gemCaps[numPasses + 1].statCaps;\n\t\tlet capForReplacement = currentCap.subtract(nextCap);\n\n\t\tif (currentCap.computeEP(capForReplacement) <= 0) {\n\t\t\tcapForReplacement = currentCap;\n\t\t}\n\n\t\tlet idx = socketList.length - 1;\n\t\tfor (idx; idx >= firstIdx; idx--) {\n\t\t\tif (newStats.belowCaps(capForReplacement)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tupdatedGear = updatedGear.withGem(socketList[idx].itemSlot, socketList[idx].socketIdx, nextGem);\n\t\t\tnewStats = await this.updateGear(updatedGear);\n\t\t}\n\n\t\t// Now run a new pass to check whether we've exceeded the next stat cap\n\t\tlet nextIdx = idx + 1;\n\n\t\tif (!newStats.belowCaps(currentCap)) {\n\t\t\tnextIdx = firstIdx;\n\t\t}\n\n\t\treturn await this.fillGemsToCaps(updatedGear, socketList, gemCaps, numPasses + 1, nextIdx);\n\t}\n\n\tabstract activateMetaGem(gear: Gear): Gear;\n\n\tabstract updateGemPriority(ungemmedGear: Gear, passiveStats: Stats): void;\n\n\tabstract allowGemInSocket(gemColor: GemColor, socketColor: GemColor, itemSlot: ItemSlot, item: EquippedItem): boolean;\n}\n\nexport class PhysicalDPSGemOptimizer extends GemOptimizer {\n\tmetaGemID = 41398; // Relentless Earthsiege Diamond\n\tarpSlop = 11;\n\texpSlop = 4;\n\thitTarget: number = 8 * 32.79;\n\thitSlop = 4;\n\tuseArpGems: boolean;\n\tuseExpGems: boolean;\n\tuseAgiGems: boolean;\n\tuseStrGems: boolean;\n\tarpTarget!: number;\n\tpassiveArp!: number;\n\tarpStackDetected!: boolean;\n\tpassiveHit!: number;\n\ttearSlot!: ItemSlot | null;\n\n\tconstructor(simUI: IndividualSimUI<any>, useArpGems: boolean, useExpGems: boolean, useAgiGems: boolean, useStrGems: boolean) {\n\t\tsuper(simUI);\n\t\tthis.useArpGems = useArpGems;\n\t\tthis.useExpGems = useExpGems;\n\t\tthis.useAgiGems = useAgiGems;\n\t\tthis.useStrGems = useStrGems;\n\t}\n\n\tupdateGemPriority(ungemmedGear: Gear, passiveStats: Stats) {\n\t\t// First calculate any gear-dependent stat caps.\n\t\tthis.arpTarget = this.calcArpTarget(ungemmedGear);\n\t\tconst critCap = this.calcCritCap(ungemmedGear);\n\t\tconst expCap = new Stats().withStat(Stat.StatExpertise, this.calcExpTarget() + this.expSlop);\n\t\tthis.passiveHit = passiveStats.getStat(Stat.StatMeleeHit);\n\t\tconst hitCap = new Stats().withStat(Stat.StatMeleeHit, this.hitTarget + this.hitSlop);\n\n\t\t// Reset optimal Tear slot from prior calculations\n\t\tthis.tearSlot = null;\n\n\t\t/*\n\t\t * For specs that gem ArP, determine whether the current gear\n\t\t * configuration will optimally hard stack Fractured gems or not.\n\t\t */\n\t\tthis.passiveArp = passiveStats.getStat(Stat.StatArmorPenetration);\n\t\tthis.arpStackDetected = this.detectArpStackConfiguration(ungemmedGear);\n\n\t\t/*\n\t\t * Use tighter constraint on overcapping ArP for hard stack setups, so as\n\t\t * to reduce the number of missed yellow socket bonuses.\n\t\t */\n\t\tconst arpSlop = this.arpStackDetected ? 4 : this.arpSlop;\n\t\tconst arpCap = new Stats().withStat(Stat.StatArmorPenetration, this.arpTarget + arpSlop);\n\n\t\t// Update red gem priority\n\t\tconst redGemCaps = new Array<GemCapsData>();\n\n\t\t// Fractured Cardinal Ruby\n\t\tif (this.useArpGems) {\n\t\t\tredGemCaps.push({ gemId: 40117, statCaps: arpCap });\n\t\t}\n\n\t\t// Precise Cardinal Ruby\n\t\tif (this.useExpGems) {\n\t\t\tredGemCaps.push({ gemId: 40118, statCaps: expCap });\n\t\t}\n\n\t\t// Delicate Cardinal Ruby\n\t\tif (this.useAgiGems) {\n\t\t\tredGemCaps.push({ gemId: 40112, statCaps: critCap });\n\t\t}\n\n\t\t// Bold Cardinal Ruby\n\t\tif (this.useStrGems) {\n\t\t\tredGemCaps.push({ gemId: 40111, statCaps: new Stats() });\n\t\t}\n\n\t\tthis.gemPriorityByColor[GemColor.GemColorRed] = redGemCaps;\n\n\t\t// Update yellow gem priority\n\t\tconst yellowGemCaps = new Array<GemCapsData>();\n\n\t\t// Accurate Ametrine\n\t\tif (this.useExpGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40162, statCaps: hitCap.add(expCap) });\n\t\t}\n\n\t\t// Rigid Ametrine\n\t\tyellowGemCaps.push({ gemId: 40125, statCaps: hitCap });\n\n\t\t// Fractured Cardinal Ruby\n\t\tif (this.arpStackDetected) {\n\t\t\tyellowGemCaps.push({ gemId: 40117, statCaps: arpCap });\n\t\t}\n\n\t\t// Accurate Ametrine (needed to add twice to catch some edge cases)\n\t\tif (this.useExpGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40162, statCaps: hitCap.add(expCap) });\n\t\t}\n\n\t\t// Glinting Ametrine\n\t\tif (this.useAgiGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40148, statCaps: hitCap.add(critCap) });\n\t\t}\n\n\t\t// Etched Ametrine\n\t\tif (this.useStrGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40143, statCaps: hitCap });\n\t\t}\n\n\t\t// Deadly Ametrine\n\t\tif (this.useAgiGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40147, statCaps: critCap });\n\t\t}\n\n\t\t// Inscribed Ametrine\n\t\tif (this.useStrGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40142, statCaps: critCap });\n\t\t}\n\n\t\t// Fierce Ametrine\n\t\tif (this.useStrGems) {\n\t\t\tyellowGemCaps.push({ gemId: 40146, statCaps: new Stats() });\n\t\t}\n\n\t\tthis.gemPriorityByColor[GemColor.GemColorYellow] = yellowGemCaps;\n\n\t\t// Update JC upgrade priority\n\t\tthis.jcUpgradePriority = new Array<GemCapsData>();\n\n\t\tif (this.useExpGems) {\n\t\t\tthis.jcUpgradePriority.push({ gemId: 40118, statCaps: expCap });\n\t\t}\n\n\t\tif (this.useAgiGems) {\n\t\t\tthis.jcUpgradePriority.push({ gemId: 40112, statCaps: critCap });\n\t\t}\n\n\t\tif (this.useStrGems) {\n\t\t\tthis.jcUpgradePriority.push({ gemId: 40111, statCaps: new Stats() });\n\t\t}\n\t}\n\n\tdetectArpStackConfiguration(ungemmedGear: Gear): boolean {\n\t\tif (!this.useArpGems) {\n\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t * Generate a \"dummy\" list of red sockets in order to determine whether\n\t\t * ignoring yellow socket bonuses to stack more ArP gems will be correct.\n\t\t * Subtract 2 from the length of this list to account for meta gem +\n\t\t * Nightmare Tear.\n\t\t */\n\t\tconst dummyRedSocketList = this.findSocketsByColor(ungemmedGear, GemColor.GemColorRed);\n\t\tconst numRedSockets = dummyRedSocketList.length - 2;\n\t\tlet projectedArp = this.passiveArp + 20 * numRedSockets;\n\n\t\tif (this.useJcGems) {\n\t\t\tprojectedArp += 42;\n\t\t}\n\n\t\treturn this.arpTarget > 1000 && projectedArp > 648 && projectedArp + 20 < this.arpTarget + 4;\n\t}\n\n\tactivateMetaGem(gear: Gear): Gear {\n\t\t/*\n\t\t * Use a single Nightmare Tear for meta activation. Prioritize blue\n\t\t * sockets for it if possible, and fall back to yellow sockets if not.\n\t\t */\n\t\tconst blueSlotCandidate = this.findBlueTearSlot(gear);\n\t\tconst yellowSlotCandidate = this.findYellowTearSlot(gear);\n\n\t\tlet tearColor = GemColor.GemColorBlue;\n\t\tthis.tearSlot = blueSlotCandidate.itemSlot;\n\n\t\tif (this.tearSlot == null || (this.arpStackDetected && yellowSlotCandidate.socketBonus > blueSlotCandidate.socketBonus)) {\n\t\t\ttearColor = GemColor.GemColorYellow;\n\t\t\tthis.tearSlot = yellowSlotCandidate.itemSlot;\n\t\t}\n\n\t\treturn this.socketTear(gear, tearColor);\n\t}\n\n\tsocketTear(gear: Gear, tearColor: GemColor): Gear {\n\t\treturn this.socketGemInFirstMatchingSocket(gear, this.tearSlot, tearColor, 49110);\n\t}\n\n\tfindBlueTearSlot(gear: Gear): SocketBonusData {\n\t\t// Eligible Tear slots have only one blue socket max.\n\t\tconst singleOnly = true;\n\n\t\t/*\n\t\t * Additionally, for hard ArP stack configurations, only use blue sockets\n\t\t * for Tear if there are no yellow sockets in that item slot, since hard\n\t\t * ArP stacks ignore yellow socket bonuses in favor of stacking more\n\t\t * Fractured gems.\n\t\t */\n\t\tconst blacklistedColor = this.arpStackDetected ? GemColor.GemColorYellow : null;\n\n\t\treturn this.findStrongestSocketBonus(gear, GemColor.GemColorBlue, singleOnly, blacklistedColor);\n\t}\n\n\tfindYellowTearSlot(gear: Gear): SocketBonusData {\n\t\treturn this.findStrongestSocketBonus(gear, GemColor.GemColorYellow, false, GemColor.GemColorBlue);\n\t}\n\n\tallowGemInSocket(gemColor: GemColor, socketColor: GemColor, itemSlot: ItemSlot, item: EquippedItem): boolean {\n\t\tconst ignoreYellowSockets = item!.numSocketsOfColor(GemColor.GemColorBlue) > 0 && itemSlot != this.tearSlot;\n\t\tlet matchYellowSocket = false;\n\n\t\tif (socketColor == GemColor.GemColorYellow && !ignoreYellowSockets) {\n\t\t\tmatchYellowSocket = new Stats(item.item.socketBonus).computeEP(this.epWeights) > 1e-8;\n\t\t}\n\n\t\treturn (gemColor == GemColor.GemColorYellow && matchYellowSocket) || (gemColor == GemColor.GemColorRed && !matchYellowSocket);\n\t}\n\n\tfindSocketsByColor(gear: Gear, color: GemColor): Array<SocketData> {\n\t\tconst socketList = super.findSocketsByColor(gear, color);\n\n\t\tif (this.arpStackDetected && color == GemColor.GemColorYellow) {\n\t\t\tthis.sortYellowSockets(gear, socketList);\n\t\t}\n\n\t\treturn socketList;\n\t}\n\n\tsortYellowSockets(gear: Gear, yellowSocketList: Array<SocketData>) {\n\t\tyellowSocketList.sort((a, b) => {\n\t\t\t// If both yellow sockets belong to the same item, then treat them equally.\n\t\t\tconst slot1 = a.itemSlot;\n\t\t\tconst slot2 = b.itemSlot;\n\n\t\t\tif (slot1 == slot2) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// If an item already has a Nightmare Tear socketed, then bump up any yellow sockets in it to highest priority.\n\t\t\tif (slot1 == this.tearSlot) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (slot2 == this.tearSlot) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// For all other cases, sort by the ratio of the socket bonus value divided by the number of yellow sockets required to activate it.\n\t\t\tconst item1 = gear.getEquippedItem(slot1);\n\t\t\tconst bonus1 = new Stats(item1!.item.socketBonus).computeEP(this.epWeights);\n\t\t\tconst item2 = gear.getEquippedItem(slot2);\n\t\t\tconst bonus2 = new Stats(item2!.item.socketBonus).computeEP(this.epWeights);\n\t\t\treturn bonus2 / item2!.numSocketsOfColor(GemColor.GemColorYellow) - bonus1 / item1!.numSocketsOfColor(GemColor.GemColorYellow);\n\t\t});\n\t}\n\n\tcalcArpTarget(gear: Gear): number {\n\t\tlet arpTarget = 1399;\n\n\t\t/*\n\t\t * First handle ArP proc trinkets. If more than one of these are equipped\n\t\t * simultaneously, it is assumed that the user is desyncing them via ICD\n\t\t * resets, such that the soft cap is set by the strongest proc.\n\t\t */\n\t\tif (gear.hasTrinket(45931)) {\n\t\t\tarpTarget -= 751; // Mjolnir Runestone\n\t\t} else if (gear.hasTrinket(50198)) {\n\t\t\tarpTarget -= 678; // Needle-Encrusted Scorpion\n\t\t} else if (gear.hasTrinket(40256)) {\n\t\t\tarpTarget -= 612; // Grim Toll\n\t\t}\n\n\t\t// Then check for Executioner enchant\n\t\tconst weapon = gear.getEquippedItem(ItemSlot.ItemSlotMainHand);\n\n\t\tif (weapon?.enchant?.effectId == 3225) {\n\t\t\tarpTarget -= 120;\n\t\t}\n\n\t\treturn arpTarget;\n\t}\n\n\tcalcExpTarget(): number {\n\t\treturn 6.5 * 32.79;\n\t}\n\n\tcalcCritCap(gear: Gear): Stats {\n\t\t/*\n\t\t * Only some specs incorporate Crit soft caps into their gemming logic, so\n\t\t * the parent method here simply returns an empty Stats object (meaning\n\t\t * that Crit cap will just be ignored elsewhere in the code). Custom\n\t\t * spec-specific subclasses can override this as desired.\n\t\t */\n\t\treturn new Stats();\n\t}\n\n\tasync fillGemsByColor(gear: Gear, color: GemColor): Promise<Gear> {\n\t\t/*\n\t\t * Parent logic substitutes JC gems after filling normal gems first, but\n\t\t * for specs that gem ArP, it is more optimal to pre-fill some Fractured\n\t\t * Dragon's Eyes if doing so gets us closer to the target.\n\t\t */\n\t\tlet updatedGear: Gear = gear;\n\n\t\tif (color == GemColor.GemColorRed && this.useArpGems && this.useJcGems) {\n\t\t\tupdatedGear = this.optimizeJcArpGems(updatedGear);\n\t\t}\n\n\t\t// Likewise, if we still have JC gems available after finishing the red gems, then force utilization of JC Hit gems if possible.\n\t\tif (color == GemColor.GemColorYellow && this.useJcGems && this.numSocketedJcGems < 3) {\n\t\t\tupdatedGear = this.fillJcHitGems(updatedGear);\n\t\t}\n\n\t\treturn await super.fillGemsByColor(updatedGear, color);\n\t}\n\n\tcalcDistanceToArpTarget(numJcArpGems: number, numRedSockets: number): number {\n\t\tconst numNormalArpGems = Math.max(\n\t\t\t0,\n\t\t\tMath.min(numRedSockets - 3, Math.floor((this.arpTarget + this.arpSlop - this.passiveArp - 34 * numJcArpGems) / 20)),\n\t\t);\n\t\tconst projectedArp = this.passiveArp + 34 * numJcArpGems + 20 * numNormalArpGems;\n\t\treturn Math.abs(projectedArp - this.arpTarget);\n\t}\n\n\toptimizeJcArpGems(gear: Gear): Gear {\n\t\t// First determine how many of the JC gems should be 34 ArP gems\n\t\tconst redSocketList = this.findSocketsByColor(gear, GemColor.GemColorRed);\n\t\tconst numRedSockets = redSocketList.length;\n\t\tlet optimalJcArpGems = [0, 1, 2, 3].reduce((m, x) =>\n\t\t\tthis.calcDistanceToArpTarget(m, numRedSockets) < this.calcDistanceToArpTarget(x, numRedSockets) ? m : x,\n\t\t);\n\t\toptimalJcArpGems = Math.min(optimalJcArpGems, numRedSockets);\n\n\t\t// Now socket just those gems, saving other JC substitutions for later\n\t\tlet updatedGear: Gear = gear;\n\n\t\tfor (let i = 0; i < optimalJcArpGems; i++) {\n\t\t\tupdatedGear = updatedGear.withGem(redSocketList[i].itemSlot, redSocketList[i].socketIdx, this.sim.db.lookupGem(42153));\n\t\t}\n\n\t\tthis.numSocketedJcGems = optimalJcArpGems;\n\t\treturn updatedGear;\n\t}\n\n\tfillJcHitGems(gear: Gear): Gear {\n\t\tconst yellowSocketList = this.findSocketsByColor(gear, GemColor.GemColorYellow);\n\t\tconst maxJcHitGems = Math.min(3 - this.numSocketedJcGems, yellowSocketList.length);\n\t\tconst desiredJcHitGems = Math.max(0, Math.floor((this.hitTarget + this.hitSlop - this.passiveHit) / 34));\n\t\tconst numJcHitGems = Math.min(desiredJcHitGems, maxJcHitGems);\n\n\t\tlet updatedGear: Gear = gear;\n\n\t\tfor (let i = 0; i < numJcHitGems; i++) {\n\t\t\tupdatedGear = updatedGear.withGem(yellowSocketList[i].itemSlot, yellowSocketList[i].socketIdx, this.sim.db.lookupGem(42156));\n\t\t}\n\n\t\tthis.numSocketedJcGems += numJcHitGems;\n\t\treturn updatedGear;\n\t}\n}\n\nexport class TankGemOptimizer extends GemOptimizer {\n\tmetaGemID = 41380; // Austere Earthsiege Diamond\n\n\tupdateGemPriority(ungemmedGear: Gear, passiveStats: Stats) {\n\t\t// Base class just stuffs pure Stamina gems everywhere\n\t\tconst blueGemCaps = new Array<GemCapsData>();\n\t\tblueGemCaps.push({ gemId: 40119, statCaps: new Stats() });\n\t\tthis.gemPriorityByColor[GemColor.GemColorBlue] = blueGemCaps;\n\t\tthis.jcUpgradePriority = blueGemCaps;\n\t}\n\n\tactivateMetaGem(gear: Gear): Gear {\n\t\t/*\n\t\t * Use a single Shifting Dreadstone gem for meta activation, in the slot\n\t\t * with the strongest bonus for a single red socket.\n\t\t */\n\t\treturn this.socketGemInFirstMatchingSocket(\n\t\t\tgear,\n\t\t\tthis.findStrongestSocketBonus(gear, GemColor.GemColorRed, true, GemColor.GemColorYellow).itemSlot,\n\t\t\tGemColor.GemColorRed,\n\t\t\t40130,\n\t\t);\n\t}\n\n\tallowGemInSocket(gemColor: GemColor, socketColor: GemColor, itemSlot: ItemSlot, item: EquippedItem): boolean {\n\t\treturn gemColor == GemColor.GemColorBlue;\n\t}\n}\n","import * as InputHelpers from '../../core/components/input_helpers.js';\nimport { Player } from '../../core/player.js';\nimport { APLRotation_Type } from '../../core/proto/apl.js';\nimport { Spec } from '../../core/proto/common.js';\nimport { FeralDruid_Rotation_AplType as AplType, FeralDruid_Rotation_BiteModeType as BiteModeType } from '../../core/proto/druid.js';\nimport { TypedEvent } from '../../core/typed_event.js';\n\n// Configuration for spec-specific UI elements on the settings tab.\n// These don't need to be in a separate file but it keeps things cleaner.\n\nexport const LatencyMs = InputHelpers.makeSpecOptionsNumberInput<Spec.SpecFeralDruid>({\n\tfieldName: 'latencyMs',\n\tlabel: 'Latency',\n\tlabelTooltip: 'Player latency, in milliseconds. Adds a delay to actions that cannot be spell queued.',\n});\n\nexport const AssumeBleedActive = InputHelpers.makeSpecOptionsBooleanInput<Spec.SpecFeralDruid>({\n\tfieldName: 'assumeBleedActive',\n\tlabel: 'Assume Bleed Always Active',\n\tlabelTooltip: \"Assume bleed always exists for 'Rend and Tear' calculations. Otherwise will only calculate based on own rip/rake/lacerate.\",\n\textraCssClasses: ['within-raid-sim-hide'],\n});\n\nfunction ShouldShowAdvParamST(player: Player<Spec.SpecFeralDruid>): boolean {\n\tconst rot = player.getSimpleRotation();\n\treturn rot.manualParams && rot.rotationType == AplType.SingleTarget;\n}\n\nfunction ShouldShowAdvParamAoe(player: Player<Spec.SpecFeralDruid>): boolean {\n\tconst rot = player.getSimpleRotation();\n\treturn rot.manualParams && rot.rotationType == AplType.Aoe;\n}\n\nexport const FeralDruidRotationConfig = {\n\tinputs: [\n\t\tInputHelpers.makeRotationEnumInput<Spec.SpecFeralDruid, AplType>({\n\t\t\tfieldName: 'rotationType',\n\t\t\tlabel: 'Type',\n\t\t\tvalues: [\n\t\t\t\t{ name: 'Single Target', value: AplType.SingleTarget },\n\t\t\t\t{ name: 'AOE', value: AplType.Aoe },\n\t\t\t],\n\t\t}),\n\t\tInputHelpers.makeRotationBooleanInput<Spec.SpecFeralDruid>({\n\t\t\tfieldName: 'maintainFaerieFire',\n\t\t\tlabel: 'Maintain Faerie Fire',\n\t\t\tlabelTooltip: 'Maintain Faerie Fire debuff. Overwrites any external Sunder effects specified in settings.',\n\t\t}),\n\t\tInputHelpers.makeRotationBooleanInput<Spec.SpecFeralDruid>({\n\t\t\tfieldName: 'manualParams',\n\t\t\tlabel: 'Manual Advanced Parameters',\n\t\t\tlabelTooltip: 'Manually specify advanced parameters, otherwise will use preset defaults',\n\t\t}),\n\t\tInputHelpers.makeRotationNumberInput<Spec.SpecFeralDruid>({\n\t\t\tfieldName: 'minRoarOffset',\n\t\t\tlabel: 'Roar Offset',\n\t\t\tlabelTooltip: 'Targeted offset in Rip/Roar timings',\n\t\t\tshowWhen: ShouldShowAdvParamST,\n\t\t}),\n\t\tInputHelpers.makeRotationNumberInput<Spec.SpecFeralDruid>({\n\t\t\tfieldName: 'ripLeeway',\n\t\t\tlabel: 'Rip Leeway',\n\t\t\tlabelTooltip: 'Rip leeway when determining roar clips',\n\t\t\tshowWhen: ShouldShowAdvParamST,\n\t\t}),\n\t\tInputHelpers.makeRotationBooleanInput<Spec.SpecFeralDruid>({\n\t\t\tfieldName: 'useRake',\n\t\t\tlabel: 'Use Rake',\n\t\t\tlabelTooltip: 'Use rake during rotation',\n\t\t\tshowWhen: ShouldShowAdvParamST,\n\t\t}),\n\t\tInputHelpers.makeRotationBooleanInput<Spec.SpecFeralDruid>({\n\t\t\tfieldName: 'useBite',\n\t\t\tlabel: 'Bite during rotation',\n\t\t\tlabelTooltip: 'Use bite during rotation rather than just at end',\n\t\t\tshowWhen: ShouldShowAdvParamST,\n\t\t}),\n\t\tInputHelpers.makeRotationNumberInput<Spec.SpecFeralDruid>({\n\t\t\tfieldName: 'biteTime',\n\t\t\tlabel: 'Bite Time',\n\t\t\tlabelTooltip: 'Min seconds on Rip/Roar to bite',\n\t\t\tshowWhen: (player: Player<Spec.SpecFeralDruid>) =>\n\t\t\t\tShouldShowAdvParamST(player) && player.getSimpleRotation().useBite == true && player.getSimpleRotation().biteModeType == BiteModeType.Emperical,\n\t\t}),\n\t\t// Can be uncommented if/when analytical bite mode is added\n\t\t//InputHelpers.makeRotationEnumInput<Spec.SpecFeralDruid, BiteModeType>({\n\t\t//\tfieldName: 'biteModeType',\n\t\t//\tlabel: 'Bite Mode',\n\t\t//\tlabelTooltip: 'Underlying \"Bite logic\" to use',\n\t\t//\tvalues: [\n\t\t//\t\t{ name: 'Emperical', value: BiteModeType.Emperical },\n\t\t//\t],\n\t\t//\tshowWhen: (player: Player<Spec.SpecFeralDruid>) => player.getSimpleRotation().useBite == true\n\t\t//}),\n\t],\n};\n","import * as PresetUtils from '../../core/preset_utils';\nimport { Consumes, Flask, Food, Glyphs, Potions, Spec, TinkerHands } from '../../core/proto/common';\nimport {\n\tDruidPrimeGlyph,\n\tDruidMajorGlyph,\n\tDruidMinorGlyph,\n\tFeralDruid_Options as FeralDruidOptions,\n\tFeralDruid_Rotation as FeralDruidRotation,\n\tFeralDruid_Rotation_AplType,\n\tFeralDruid_Rotation_BearweaveType,\n\tFeralDruid_Rotation_BiteModeType,\n} from '../../core/proto/druid';\nimport { SavedTalents } from '../../core/proto/ui';\n// Preset options for this spec.\n// Eventually we will import these values for the raid sim too, so its good to\n// keep them in a separate file.\nimport PreraidGear from './gear_sets/preraid.gear.json';\nexport const PRERAID_PRESET = PresetUtils.makePresetGear('Preraid Preset', PreraidGear);\nimport P1Gear from './gear_sets/p1.gear.json';\nexport const P1_PRESET = PresetUtils.makePresetGear('P1 Preset', P1Gear);\nimport P2Gear from './gear_sets/p2.gear.json';\nexport const P2_PRESET = PresetUtils.makePresetGear('P2 Preset', P2Gear);\nimport P3Gear from './gear_sets/p3.gear.json';\nexport const P3_PRESET = PresetUtils.makePresetGear('P3 Preset', P3Gear);\nimport P4Gear from './gear_sets/p4.gear.json';\nexport const P4_PRESET = PresetUtils.makePresetGear('P4 Preset', P4Gear);\n\nimport DefaultApl from './apls/default.apl.json';\nexport const APL_ROTATION_DEFAULT = PresetUtils.makePresetAPLRotation('APL Default', DefaultApl);\n\nimport CustomExampleApl from './apls/custom_apl_example.apl.json';\nexport const APL_ROTATION_CUSTOM_EXAMPLE = PresetUtils.makePresetAPLRotation('Custom APL Example', CustomExampleApl);\n\nexport const DefaultRotation = FeralDruidRotation.create({\n\trotationType: FeralDruid_Rotation_AplType.SingleTarget,\n\n\tbearWeaveType: FeralDruid_Rotation_BearweaveType.None,\n\tminCombosForRip: 5,\n\tminCombosForBite: 5,\n\n\tuseRake: true,\n\tuseBite: true,\n\tmangleSpam: false,\n\tbiteModeType: FeralDruid_Rotation_BiteModeType.Emperical,\n\tbiteTime: 4.0,\n\tberserkBiteThresh: 25.0,\n\tpowerbear: false,\n\tminRoarOffset: 12.0,\n\tripLeeway: 3.0,\n\tmaintainFaerieFire: true,\n\tsnekWeave: false,\n});\n\nexport const SIMPLE_ROTATION_DEFAULT = PresetUtils.makePresetSimpleRotation('Simple Default', Spec.SpecFeralDruid, DefaultRotation);\n\n// Default talents. Uses the wowhead calculator format, make the talents on\n// https://wowhead.com/cata/talent-calc and copy the numbers in the url.\nexport const StandardTalents = {\n\tname: 'Standard',\n\tdata: SavedTalents.create({\n\t\ttalentsString: '-2320322312012121202301-020301',\n\t\tglyphs: Glyphs.create({\n\t\t\tprime1: DruidPrimeGlyph.GlyphOfRip,\n\t\t\tprime2: DruidPrimeGlyph.GlyphOfBloodletting,\n\t\t\tprime3: DruidPrimeGlyph.GlyphOfBerserk,\n\t\t\tmajor1: DruidMajorGlyph.GlyphOfThorns,\n\t\t\tmajor2: DruidMajorGlyph.GlyphOfFeralCharge,\n\t\t\tmajor3: DruidMajorGlyph.GlyphOfRebirth,\n\t\t\tminor1: DruidMinorGlyph.GlyphOfDash,\n\t\t\tminor2: DruidMinorGlyph.GlyphOfMarkOfTheWild,\n\t\t\tminor3: DruidMinorGlyph.GlyphOfUnburdenedRebirth,\n\t\t}),\n\t}),\n};\n\nexport const DefaultOptions = FeralDruidOptions.create({\n\tlatencyMs: 100,\n\tassumeBleedActive: true,\n});\n\nexport const DefaultConsumes = Consumes.create({\n\tflask: Flask.FlaskOfTheWinds,\n\tfood: Food.FoodSkeweredEel,\n\tdefaultPotion: Potions.PotionOfTheTolvir,\n\tprepopPotion: Potions.PotionOfTheTolvir,\n\ttinkerHands: TinkerHands.TinkerHandsSynapseSprings,\n});\n","import * as BuffDebuffInputs from '../../core/components/inputs/buffs_debuffs.js';\nimport * as OtherInputs from '../../core/components/other_inputs.js';\nimport { PhysicalDPSGemOptimizer } from '../../core/components/suggest_gems_action.js';\nimport { IndividualSimUI, registerSpecConfig } from '../../core/individual_sim_ui.js';\nimport { Player } from '../../core/player.js';\nimport { PlayerClasses } from '../../core/player_classes';\nimport { APLAction, APLListItem, APLPrepullAction, APLRotation } from '../../core/proto/apl.js';\nimport { Cooldowns, Debuffs, Faction, IndividualBuffs, PartyBuffs, PseudoStat, Race, RaidBuffs, Spec, Stat, TristateEffect } from '../../core/proto/common.js';\nimport { FeralDruid_Rotation as DruidRotation } from '../../core/proto/druid.js';\nimport * as AplUtils from '../../core/proto_utils/apl_utils.js';\nimport { Gear } from '../../core/proto_utils/gear.js';\nimport { Stats } from '../../core/proto_utils/stats.js';\nimport * as FeralInputs from './inputs.js';\nimport * as Presets from './presets.js';\n\nconst SPEC_CONFIG = registerSpecConfig(Spec.SpecFeralDruid, {\n\tcssClass: 'feral-druid-sim-ui',\n\tcssScheme: PlayerClasses.getCssClass(PlayerClasses.Druid),\n\t// List any known bugs / issues here and they'll be shown on the site.\n\tknownIssues: [],\n\twarnings: [],\n\n\t// All stats for which EP should be calculated.\n\tepStats: [\n\t\tStat.StatStrength,\n\t\tStat.StatAgility,\n\t\tStat.StatAttackPower,\n\t\tStat.StatMeleeHit,\n\t\tStat.StatExpertise,\n\t\tStat.StatMeleeCrit,\n\t\tStat.StatMeleeHaste,\n\t\tStat.StatMastery,\n\t],\n\tepPseudoStats: [PseudoStat.PseudoStatMainHandDps],\n\t// Reference stat against which to calculate EP. I think all classes use either spell power or attack power.\n\tepReferenceStat: Stat.StatAttackPower,\n\t// Which stats to display in the Character Stats section, at the bottom of the left-hand sidebar.\n\tdisplayStats: [\n\t\tStat.StatHealth,\n\t\tStat.StatStrength,\n\t\tStat.StatAgility,\n\t\tStat.StatAttackPower,\n\t\tStat.StatMeleeHit,\n\t\tStat.StatExpertise,\n\t\tStat.StatMeleeCrit,\n\t\tStat.StatMeleeHaste,\n\t\tStat.StatMastery,\n\t\tStat.StatMana,\n\t],\n\n\tdefaults: {\n\t\t// Default equipped gear.\n\t\tgear: Presets.PRERAID_PRESET.gear,\n\t\t// Default EP weights for sorting gear in the gear picker.\n\t\tepWeights: Stats.fromMap(\n\t\t\t{\n\t\t\t\t[Stat.StatStrength]: 0.38,\n\t\t\t\t[Stat.StatAgility]: 1.0,\n\t\t\t\t[Stat.StatAttackPower]: 0.37,\n\t\t\t\t[Stat.StatMeleeHit]: 0.43,\n\t\t\t\t[Stat.StatExpertise]: 0.43,\n\t\t\t\t[Stat.StatMeleeCrit]: 0.40,\n\t\t\t\t[Stat.StatMeleeHaste]: 0.41,\n\t\t\t\t[Stat.StatMastery]: 0.58,\n\t\t\t},\n\t\t\t{\n\t\t\t\t[PseudoStat.PseudoStatMainHandDps]: 1.55,\n\t\t\t},\n\t\t),\n\t\t// Default consumes settings.\n\t\tconsumes: Presets.DefaultConsumes,\n\t\t// Default talents.\n\t\ttalents: Presets.StandardTalents.data,\n\t\t// Default spec-specific settings.\n\t\tspecOptions: Presets.DefaultOptions,\n\t\t// Default raid/party buffs settings.\n\t\traidBuffs: RaidBuffs.create({\n\t\t\tmarkOfTheWild: true,\n\t\t\tstrengthOfEarthTotem: true,\n\t\t\tabominationsMight: true,\n\t\t\twindfuryTotem: true,\n\t\t\tbloodlust: true,\n\t\t\tcommunion: true,\n\t\t\tarcaneBrilliance: true,\n\t\t\tmanaSpringTotem: true,\n\t\t}),\n\t\tpartyBuffs: PartyBuffs.create({\n\t\t}),\n\t\tindividualBuffs: IndividualBuffs.create({\n\t\t}),\n\t\tdebuffs: Debuffs.create({\n\t\t\tsavageCombat: true,\n\t\t}),\n\t},\n\n\t// IconInputs to include in the 'Player' section on the settings tab.\n\tplayerIconInputs: [],\n\t// Inputs to include in the 'Rotation' section on the settings tab.\n\trotationInputs: FeralInputs.FeralDruidRotationConfig,\n\t// Buff and Debuff inputs to include/exclude, overriding the EP-based defaults.\n\tincludeBuffDebuffInputs: [BuffDebuffInputs.ManaBuff, BuffDebuffInputs.MP5Buff],\n\texcludeBuffDebuffInputs: [],\n\t// Inputs to include in the 'Other' section on the settings tab.\n\totherInputs: {\n\t\tinputs: [FeralInputs.LatencyMs, FeralInputs.AssumeBleedActive, OtherInputs.TankAssignment, OtherInputs.InFrontOfTarget, OtherInputs.DarkIntentUptime],\n\t},\n\tencounterPicker: {\n\t\t// Whether to include 'Execute Duration (%)' in the 'Encounter' section of the settings tab.\n\t\tshowExecuteProportion: true,\n\t},\n\n\tpresets: {\n\t\t// Preset talents that the user can quickly select.\n\t\ttalents: [Presets.StandardTalents],\n\t\trotations: [Presets.SIMPLE_ROTATION_DEFAULT, Presets.APL_ROTATION_DEFAULT, Presets.APL_ROTATION_CUSTOM_EXAMPLE],\n\t\t// Preset gear configurations that the user can quickly select.\n\t\tgear: [Presets.PRERAID_PRESET, Presets.P1_PRESET, Presets.P2_PRESET, Presets.P3_PRESET, Presets.P4_PRESET],\n\t},\n\n\tautoRotation: (_player: Player<Spec.SpecFeralDruid>): APLRotation => {\n\t\treturn Presets.APL_ROTATION_DEFAULT.rotation.rotation!;\n\t},\n\n\tsimpleRotation: (player: Player<Spec.SpecFeralDruid>, simple: DruidRotation, cooldowns: Cooldowns): APLRotation => {\n\t\tconst [prepullActions, actions] = AplUtils.standardCooldownDefaults(cooldowns);\n\n\t\tconst blockZerk = APLAction.fromJsonString(`{\"condition\":{\"const\":{\"val\":\"false\"}},\"castSpell\":{\"spellId\":{\"spellId\":50334}}}`);\n\t\tconst doRotation = APLAction.fromJsonString(`{\"catOptimalRotationAction\":{\"rotationType\":${simple.rotationType},\"manualParams\":${simple.manualParams},\"maintainFaerieFire\":${simple.maintainFaerieFire},\"minRoarOffset\":${simple.minRoarOffset.toFixed(2)},\"ripLeeway\":${simple.ripLeeway.toFixed(0)},\"useRake\":${simple.useRake},\"useBite\":${simple.useBite},\"biteTime\":${simple.biteTime.toFixed(2)}}}`);\n\n\t\tactions.push(...([blockZerk, doRotation].filter(a => a) as Array<APLAction>));\n\n\t\treturn APLRotation.create({\n\t\t\tprepullActions: prepullActions,\n\t\t\tpriorityList: actions.map(action =>\n\t\t\t\tAPLListItem.create({\n\t\t\t\t\taction: action,\n\t\t\t\t}),\n\t\t\t),\n\t\t});\n\t},\n\n\traidSimPresets: [\n\t\t{\n\t\t\tspec: Spec.SpecFeralDruid,\n\t\t\ttalents: Presets.StandardTalents.data,\n\t\t\tspecOptions: Presets.DefaultOptions,\n\t\t\tconsumes: Presets.DefaultConsumes,\n\t\t\tdefaultFactionRaces: {\n\t\t\t\t[Faction.Unknown]: Race.RaceUnknown,\n\t\t\t\t[Faction.Alliance]: Race.RaceNightElf,\n\t\t\t\t[Faction.Horde]: Race.RaceTauren,\n\t\t\t},\n\t\t\tdefaultGear: {\n\t\t\t\t[Faction.Unknown]: {},\n\t\t\t\t[Faction.Alliance]: {\n\t\t\t\t\t1: Presets.P1_PRESET.gear,\n\t\t\t\t\t2: Presets.P2_PRESET.gear,\n\t\t\t\t\t3: Presets.P3_PRESET.gear,\n\t\t\t\t\t4: Presets.P4_PRESET.gear,\n\t\t\t\t},\n\t\t\t\t[Faction.Horde]: {\n\t\t\t\t\t1: Presets.P1_PRESET.gear,\n\t\t\t\t\t2: Presets.P2_PRESET.gear,\n\t\t\t\t\t3: Presets.P3_PRESET.gear,\n\t\t\t\t\t4: Presets.P4_PRESET.gear,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t],\n});\n\nexport class FeralDruidSimUI extends IndividualSimUI<Spec.SpecFeralDruid> {\n\tconstructor(parentElem: HTMLElement, player: Player<Spec.SpecFeralDruid>) {\n\t\tsuper(parentElem, player, SPEC_CONFIG);\n\n\t\tconst _gemOptimizer = new FeralGemOptimizer(this);\n\t}\n}\n\nclass FeralGemOptimizer extends PhysicalDPSGemOptimizer {\n\tconstructor(simUI: IndividualSimUI<Spec.SpecFeralDruid>) {\n\t\tsuper(simUI, true, true, true, true);\n\t}\n\n\tcalcCritCap(gear: Gear): Stats {\n\t\tconst baseCritCapPercentage = 77.8; // includes 3% Crit debuff\n\t\tlet agiProcs = 0;\n\n\t\tif (gear.hasRelic(47668)) {\n\t\t\tagiProcs += 200;\n\t\t}\n\n\t\tif (gear.hasRelic(50456)) {\n\t\t\tagiProcs += 44 * 5;\n\t\t}\n\n\t\tif (gear.hasTrinket(47131) || gear.hasTrinket(47464)) {\n\t\t\tagiProcs += 510;\n\t\t}\n\n\t\tif (gear.hasTrinket(47115) || gear.hasTrinket(47303)) {\n\t\t\tagiProcs += 450;\n\t\t}\n\n\t\tif (gear.hasTrinket(44253) || gear.hasTrinket(42987)) {\n\t\t\tagiProcs += 300;\n\t\t}\n\n\t\treturn new Stats().withStat(Stat.StatMeleeCrit, (baseCritCapPercentage - (agiProcs * 1.1 * 1.06 * 1.02) / 83.33) * 45.91);\n\t}\n}\n"],"names":["_GemOptimizer","constructor","simUI","this","player","sim","gemPriorityByColor","gemColor","allGemColors","Array","jcUpgradePriority","addAction","async","optimizeGems","optimizedGear","getGear","withoutGems","numSocketedJcGems","epWeights","getEpWeights","useJcGems","hasProfession","Profession","Jewelcrafting","isBlacksmithing","ungemmedStats","updateGear","updateGemPriority","withMetaGem","db","lookupGem","metaGemID","activateMetaGem","length","fillGemsByColor","substituteJcGems","gear","setGear","TypedEvent","nextEventID","updateCharacterStats","Stats","fromProto","getCurrentStats","finalStats","findStrongestSocketBonus","color","singleOnly","blacklistedColor","optimalSlot","maxSocketBonusEP","slot","getItemSlots","item","getEquippedItem","numSocketsOfColor","numSockets","normalizedEP","socketBonus","computeEP","itemSlot","socketGemInFirstMatchingSocket","colorToMatch","gemId","socketIdx","socketColor","allSocketColors","entries","withEquippedItem","withGem","socketList","findSocketsByColor","fillGemsToCaps","curSocketColors","hasSocketedGem","allowGemInSocket","push","updatedGear","gemIdx","gemData","baseGem","getAllGems","includes","upgradedGem","jcUpgradesById","testGear","withSingleGemSubstitution","belowCaps","statCaps","gemCaps","numPasses","firstIdx","currentGem","socketData","slice","newStats","currentCap","nextGem","nextCap","capForReplacement","subtract","idx","nextIdx","GemColor","GemColorRed","GemColorYellow","GemColorBlue","GemOptimizer","PhysicalDPSGemOptimizer","useArpGems","useExpGems","useAgiGems","useStrGems","super","arpSlop","expSlop","hitTarget","hitSlop","ungemmedGear","passiveStats","arpTarget","calcArpTarget","critCap","calcCritCap","expCap","withStat","Stat","StatExpertise","calcExpTarget","passiveHit","getStat","StatMeleeHit","hitCap","tearSlot","passiveArp","StatArmorPenetration","arpStackDetected","detectArpStackConfiguration","arpCap","redGemCaps","yellowGemCaps","add","numRedSockets","projectedArp","blueSlotCandidate","findBlueTearSlot","yellowSlotCandidate","findYellowTearSlot","tearColor","socketTear","ignoreYellowSockets","matchYellowSocket","sortYellowSockets","yellowSocketList","sort","a","b","slot1","slot2","item1","bonus1","item2","hasTrinket","weapon","ItemSlot","ItemSlotMainHand","enchant","effectId","optimizeJcArpGems","fillJcHitGems","calcDistanceToArpTarget","numJcArpGems","numNormalArpGems","Math","max","min","floor","abs","redSocketList","optimalJcArpGems","reduce","m","x","i","maxJcHitGems","desiredJcHitGems","numJcHitGems","LatencyMs","InputHelpers.makeSpecOptionsNumberInput","fieldName","label","labelTooltip","AssumeBleedActive","InputHelpers.makeSpecOptionsBooleanInput","extraCssClasses","ShouldShowAdvParamST","rot","getSimpleRotation","manualParams","rotationType","AplType","SingleTarget","FeralDruidRotationConfig","inputs","InputHelpers.makeRotationEnumInput","values","name","value","Aoe","InputHelpers.makeRotationBooleanInput","InputHelpers.makeRotationNumberInput","showWhen","useBite","biteModeType","BiteModeType","Emperical","PRERAID_PRESET","PresetUtils.makePresetGear","P1_PRESET","P1Gear","P2_PRESET","P2Gear","P3_PRESET","P3Gear","P4_PRESET","P4Gear","APL_ROTATION_DEFAULT","PresetUtils.makePresetAPLRotation","DefaultApl","APL_ROTATION_CUSTOM_EXAMPLE","CustomExampleApl","DefaultRotation","FeralDruidRotation","create","FeralDruid_Rotation_AplType","bearWeaveType","FeralDruid_Rotation_BearweaveType","None","minCombosForRip","minCombosForBite","useRake","mangleSpam","FeralDruid_Rotation_BiteModeType","biteTime","berserkBiteThresh","powerbear","minRoarOffset","ripLeeway","maintainFaerieFire","snekWeave","SIMPLE_ROTATION_DEFAULT","PresetUtils.makePresetSimpleRotation","Spec","SpecFeralDruid","StandardTalents","data","SavedTalents","talentsString","glyphs","Glyphs","prime1","DruidPrimeGlyph","GlyphOfRip","prime2","GlyphOfBloodletting","prime3","GlyphOfBerserk","major1","DruidMajorGlyph","GlyphOfThorns","major2","GlyphOfFeralCharge","major3","GlyphOfRebirth","minor1","DruidMinorGlyph","GlyphOfDash","minor2","GlyphOfMarkOfTheWild","minor3","GlyphOfUnburdenedRebirth","DefaultOptions","FeralDruidOptions","latencyMs","assumeBleedActive","DefaultConsumes","Consumes","flask","Flask","FlaskOfTheWinds","food","Food","FoodSkeweredEel","defaultPotion","Potions","PotionOfTheTolvir","prepopPotion","tinkerHands","TinkerHands","TinkerHandsSynapseSprings","SPEC_CONFIG","registerSpecConfig","cssClass","cssScheme","PlayerClasses","getCssClass","Druid","knownIssues","warnings","epStats","StatStrength","StatAgility","StatAttackPower","StatMeleeCrit","StatMeleeHaste","StatMastery","epPseudoStats","PseudoStat","PseudoStatMainHandDps","epReferenceStat","displayStats","StatHealth","StatMana","defaults","Presets.PRERAID_PRESET","fromMap","consumes","Presets.DefaultConsumes","talents","Presets.StandardTalents","specOptions","Presets.DefaultOptions","raidBuffs","RaidBuffs","markOfTheWild","strengthOfEarthTotem","abominationsMight","windfuryTotem","bloodlust","communion","arcaneBrilliance","manaSpringTotem","partyBuffs","PartyBuffs","individualBuffs","IndividualBuffs","debuffs","Debuffs","savageCombat","playerIconInputs","rotationInputs","FeralInputs.FeralDruidRotationConfig","includeBuffDebuffInputs","BuffDebuffInputs.ManaBuff","BuffDebuffInputs.MP5Buff","excludeBuffDebuffInputs","otherInputs","FeralInputs.LatencyMs","FeralInputs.AssumeBleedActive","OtherInputs.TankAssignment","OtherInputs.InFrontOfTarget","OtherInputs.DarkIntentUptime","encounterPicker","showExecuteProportion","presets","rotations","Presets.SIMPLE_ROTATION_DEFAULT","Presets.APL_ROTATION_DEFAULT","Presets.APL_ROTATION_CUSTOM_EXAMPLE","Presets.P1_PRESET","Presets.P2_PRESET","Presets.P3_PRESET","Presets.P4_PRESET","autoRotation","_player","rotation","simpleRotation","simple","cooldowns","prepullActions","actions","AplUtils.standardCooldownDefaults","blockZerk","APLAction","fromJsonString","doRotation","toFixed","filter","APLRotation","priorityList","map","action","APLListItem","raidSimPresets","spec","defaultFactionRaces","Faction","Unknown","Race","RaceUnknown","Alliance","RaceNightElf","Horde","RaceTauren","defaultGear","FeralDruidSimUI","IndividualSimUI","parentElem","FeralGemOptimizer","agiProcs","hasRelic"],"mappings":"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"}